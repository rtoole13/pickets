<html>
<canvas id = "gameCanvas" width = "800" height = "600"></canvas>
<script type= "text/javascript">
"use strict";
var unit = new Image(1600,200);
var map_bg = new Image(800, 600);
map_bg.src = '../assets/main_map.png';
unit.src = '../assets/unit_sketch_test.svg';

var width = window.innerWidth,
	height = window.innerHeight,
	canvas = document.getElementById('gameCanvas');

var canvasContext,
	timeLast,
	mouseObj,
	mouseX = 0,
	mouseY = 0,
	objectList = [],
	unitTrails = [];

window.onload = function(){
	canvasContext = canvas.getContext("2d");

	init();
}

function init(){
	canvas.addEventListener("click", handleClick, false);
	canvas.addEventListener("mousemove", handleMouseMove, false);
	drawBackground();

	initObjects();
	timeLast = Date.now();
	main();
}

function initObjects(){
	mouseObj = new MouseObject(mouseX, mouseY, 5, 'green');

	//initialize other objects
	//objectList.push(mouseObj);
}
function handleClick(evt){
	console.log('click.');
}

function handleMouseMove(evt){
	var rect = canvas.getBoundingClientRect(),
		root = document.documentElement;

	mouseX = evt.pageX - rect.left - root.scrollLeft;
	mouseY = evt.pageY - rect.top - root.scrollTop;
}

function main(){
	var timeNow = Date.now();
	var dt = (timeNow - timeLast) / 1000.0;

	update(dt);
	render();

	timeLast = timeNow;
	requestAnimationFrame(main);
}

function update(dt){
	mouseObj.update(dt);
}

function render(){
	drawBackground();
	drawObjects();
}

function drawBackground(){
	canvasContext.drawImage(map_bg, 0, 0, 800, 600);
}

function drawObjects(){
	/*
	for (var i = 0; i < objectList.length; i++){
		objectList[i].draw();
	}
	*/
	unitTrails.forEach(function(element){
		element.draw()
	});
	mouseObj.draw();
}

class GameObject {
	constructor(x, y, radius, color){
		this.x = x;
		this.y = y;
		this.radius = radius;
		this.color = color;
		
	}
	update(){

	}
	draw(){
		canvasContext.save();
		canvasContext.beginPath();
		canvasContext.fillStyle = this.color;
		canvasContext.arc(this.x, this.y, this.radius, 0, Math.PI*2, true);
		canvasContext.fill();
		canvasContext.restore();
	}
}

class SpriteSheet {
	constructor(image, x, y, width, height, frameCount, frameRate){
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		this.frameCount = frameCount;
		this.sw = Math.floor(this.width/this.frameCount);
		this.sh = this.height;

		this.image = image;
		this.frameRate = frameRate;
		this.ticksPerFrame = 1 / this.frameRate;
		this.ticks = 0;
		this.frameIndex = 0;
		this.loopAnimation = true;


	}
	update(dt, x, y){
		this.x = x;
		this.y = y;
		this.ticks += dt;
		if (this.ticks > this.ticksPerFrame){
			if (this.frameIndex < this.frameCount - 1){
				this.frameIndex += 1;
			}
			else if (this.loopAnimation){
				this.frameIndex = 0;
			}
			this.ticks = 0;
		}
	}

	draw(){
		canvasContext.drawImage(this.image, this.frameIndex * this.sw, 0, this.sw, this.sh, this.x - this.sw / 2, this.y - this.sh / 2, this.sw, this.sh);
	}
}

class MouseObject extends GameObject {
	constructor(x, y, radius, color){
		super(x, y, radius, color);
		this.attached = true;
		this.spriteSheet = new SpriteSheet(unit, this.x, this.y, 200, 50, 10, 5);
		this.trail = new Trail({x: this.x, y: this.y}, 23, 4, "#30618C", 0.5, 'bezier');
		unitTrails.push(this.trail);
	}
	update(dt){
		this.x = mouseX;
		this.y = mouseY;
		this.spriteSheet.update(dt, this.x, this.y);
		this.trail.update({x:this.x, y:this.y});
	}
	draw(){
		this.spriteSheet.draw();
	}

}

class Trail{
	constructor(initialPosition, length, lineWidth, color, alphaStart, mode){
		this.vertices = [];
		this.tempSet = [];
		this.length = length;
		//this.vertices.push(initialPosition);
		this.tempSet.push(initialPosition);
		this.lineWidth = lineWidth;
		this.alphaStart = alphaStart;
		this.colorPrefix = getColorPrefix(color);
		this.initialColor = this.colorPrefix + this.alphaStart.toString() + ')';
		this.updateTimer = new Timer(10, true);
		this.updateTimer.start();
		this.currentHead = initialPosition;
		this.minDist = 10;
		this.minDistSq = this.minDist * this.minDist;
		this.mode = mode;
	}

	update(currentPosition){
		if (this.mode == 'bezier'){
			this.updateBezier(currentPosition);
		}
		else{
			//default
			this.updateDefault(currentPosition);
		}
		
	}

	updateDefault(currentPosition){
		this.currentHead = currentPosition;
		if (this.updateTimer.checkTime()){
			if (getDistanceSq(this.vertices[0].x, this.vertices[0].y, this.currentHead.x, this.currentHead.y) > this.minDistSq){
				this.vertices.unshift(currentPosition);
				if (this.vertices.length > this.length){
					this.vertices.pop();
				}
			}
		}
	}

	updateBezier(currentPosition){
		this.currentHead = currentPosition;
		
		if (this.updateTimer.checkTime()){
			var baseX, baseY;
			if (this.tempSet.length > 0){
				baseX = this.tempSet[0].x;
				baseY = this.tempSet[0].y;
			}
			else{
				baseX = this.vertices[0].x;
				baseY = this.vertices[0].y;
			}
			if (getDistanceSq(baseX, baseY, this.currentHead.x, this.currentHead.y) > this.minDistSq){
				this.tempSet.unshift(currentPosition);

				if (this.tempSet.length > 1){
					this.vertices = this.tempSet.concat(this.vertices);
					if (this.vertices.length > this.length){
						this.vertices.pop();
						this.vertices.pop();
					}
					this.tempSet = [];
				}
			}
		}
	}

	draw(){
		if (this.mode == 'bezier'){
			this.drawBezier();
		}
		else{
			//default
			this.drawDefault();
		}

	}
	
	drawDefault(){
		canvasContext.save();
		canvasContext.beginPath();
		canvasContext.lineWidth = this.lineWidth;
		canvasContext.moveTo(this.currentHead.x, this.currentHead.y);
		var previousColor = this.initialColor;
		var currentLength = this.vertices.length;
		for (var i = 1; i < currentLength; i++){
			var lastPoint = this.vertices[i-1];
			var point = this.vertices[i];
			var gradient = canvasContext.createLinearGradient(lastPoint.x, lastPoint.y, point.x, point.y);
			var alpha = Math.round(this.alphaStart * 100 * (currentLength - 1 - i) / (currentLength - 1)) / 100; //note that there are this.length - 1 line segments. note, won't round up on .005
			var nextColor = this.colorPrefix + alpha.toString() + ')';
			gradient.addColorStop(0, previousColor); //start color
			gradient.addColorStop(1, nextColor); //end color
			previousColor = nextColor;
			canvasContext.strokeStyle = gradient;
			canvasContext.lineTo(point.x, point.y);
			canvasContext.stroke();
		}
		canvasContext.restore();
	}

	drawBezier(){
		canvasContext.save();
		canvasContext.beginPath();
		canvasContext.lineWidth = this.lineWidth;
		canvasContext.moveTo(this.currentHead.x, this.currentHead.y);
		if ((this.tempSet.length > 0) && (this.vertices.length > 0)){
			canvasContext.bezierCurveTo(this.tempSet[0].x, this.tempSet[0].y, this.tempSet[0].x, this.tempSet[0].y,
										this.vertices[0].x, this.vertices[0].y);
		}

		var previousColor = this.initialColor;
		var currentLength = this.vertices.length;
		for (var i = 0; i < (currentLength - 2); i+=2){
			var firstPoint = this.vertices[i];
			var midPoint = this.vertices[i + 1];
			var lastPoint = this.vertices[i + 2];
			
			var gradient = canvasContext.createLinearGradient(firstPoint.x, firstPoint.y, lastPoint.x, lastPoint.y);
			var alpha = Math.round(this.alphaStart * 100 * (currentLength - 1 - i) / (currentLength - 1)) / 100; //note that there are this.length - 1 line segments. note, won't round up on .005
			var nextColor = this.colorPrefix + alpha.toString() + ')';
			gradient.addColorStop(0, previousColor); //start color
			gradient.addColorStop(1, nextColor); //end color
			previousColor = nextColor;
			canvasContext.strokeStyle = gradient;
			canvasContext.bezierCurveTo(midPoint.x, midPoint.y, midPoint.x, midPoint.y, lastPoint.x, lastPoint.y);
			canvasContext.stroke();
		}
		canvasContext.restore();
	}
}

function getDistanceSq(xi, yi, xf, yf){
	//Get the distance squared between points (xi,yi) and (xf, yf)
	return getVectorMagSq(xf-xi, yf-yi);
}

function getVectorMagSq(x, y){
	//Get the magnitude squared of the vector (x,y)
	return Math.pow(x,2) + Math.pow(y,2);
}

function getColorPrefix(hex){
	hex = hex.replace("#", "");
	var r, g, b;
	r = parseInt(hex.substring(0,2), 16);
	g = parseInt(hex.substring(2,4), 16);
	b = parseInt(hex.substring(4,6), 16);
	return 'rgba(' + r.toString() + ', ' + g.toString() + ', ' + b.toString() + ', ';
}

class Timer{
	constructor(duration, repeating){
		this.duration = duration;
		this.repeating = repeating;
		this.startTime = 0;
	}
	start(){
		this.startTime = Date.now();
	}
	checkTime(){
		if ( Date.now() - this.startTime > this.duration){
			if (this.repeating){
				this.start();
			}
			return true;
		}
		return false;
	}
	getElapsedTime(){
		return (Date.now() - this.startTime);
	}
}

</script>
</html>
